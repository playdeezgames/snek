local BOARD_URL = "#board"
local SNAKE_LAYER = "snake"
local STATS_LAYER = "stats"
local BOARD_COLUMNS = 40
local BOARD_ROWS = 30
local DIRECTION_NORTH = 1
local DIRECTION_EAST = 2
local DIRECTION_SOUTH = 3
local DIRECTION_WEST = 4
local INITIAL_LENGTH = 14
local INITIAL_MOVETIMER = 0.1

local score = 0
local highScore = 0
local snakeLength = 0
local moveTimer = 0
local pelletTimer = 0
local inPlay = false
local direction = DIRECTION_SOUTH
local snake = {{x = math.floor(BOARD_COLUMNS/2), y=math.floor(BOARD_ROWS/2), pellet=false, flags=0}}
local pellets = {}
local commandQueue = {}
local opposite = {DIRECTION_SOUTH, DIRECTION_WEST, DIRECTION_NORTH, DIRECTION_EAST}
local deltaX = {0,1,0,-1}
local deltaY = {1,0,-1,0}
local flags = {1,2,4,8}

function clearBoard()
	for x = 1, BOARD_COLUMNS do
		for y = 1, BOARD_ROWS do
			tilemap.set_tile(BOARD_URL, SNAKE_LAYER, x, y, 0)
			tilemap.set_tile(BOARD_URL, STATS_LAYER, x, y, 0)
		end
	end
end

function addPellet()
	local done = false
	local x
	local y
	while not done do
		x = math.random(1, BOARD_COLUMNS)
		y = math.random(1, BOARD_ROWS)
		done = true
		for i, v in ipairs(pellets) do
			if x == v.x and y == v.y then
				done = false
			end
		end
		for i, v in ipairs(snake) do
			if x == v.x and y == v.y then
				done = false
			end
		end
	end
	table.insert(pellets, {x=x,y=y})
end

function startGame()
	score = 0
	snakeLength = INITIAL_LENGTH
	direction = DIRECTION_SOUTH
	moveTimer = INITIAL_MOVETIMER
	snake = {{x = math.floor(BOARD_COLUMNS/2), y=math.floor(BOARD_ROWS/2), pellet=false, flags=0}}
	inPlay = true
	pellets = {}
	addPellet()
end

function showSnake()
	for i, v in ipairs(snake) do
		if v.x>=1 and v.x<=BOARD_COLUMNS and v.y>=1 and v.y<=BOARD_ROWS then
			if i==1 then
				tilemap.set_tile(BOARD_URL, SNAKE_LAYER, v.x, v.y, 32 + direction)
			elseif v.pellet then
				tilemap.set_tile(BOARD_URL, SNAKE_LAYER, v.x, v.y, v.flags + 17)
			else
				tilemap.set_tile(BOARD_URL, SNAKE_LAYER, v.x, v.y, v.flags + 1)
			end
		end
	end
end

function showPellets()
	for i, v in ipairs(pellets) do
		tilemap.set_tile(BOARD_URL, SNAKE_LAYER, v.x, v.y, 37)
	end
end

function showStats()
end

function hasPellet(x,y)
	for i, v in ipairs(pellets) do
		if x==v.x and y==v.y then
			return true
		end
	end
	return false
end

function hasSnakeBody(x,y)
	for i, v in ipairs(snake) do
		if i>1 and x==v.x and y==v.y then
			return true
		end
	end
	return false
end

function removePellets(x,y)
	local purgeList = {}
	for i, v in ipairs(pellets) do
		if x==v.x and y==v.y then
			table.insert(purgeList,1,i)
		end
	end
	for i,v in ipairs(purgeList) do
		table.remove(pellets, v)
	end
end

function updateSnake(dt)
	if inPlay then
		if #commandQueue > 0 then
			local command = table.remove(commandQueue,1)
			if direction~=opposite[command] then
				direction = command
			end
		end
		moveTimer = moveTimer - dt
		if moveTimer<0 then
			moveTimer = moveTimer + INITIAL_MOVETIMER
			snake[1].flags = snake[1].flags+flags[direction]
			snake[1].direction = direction
			local nextSegment = {x = snake[1].x + deltaX[direction], y = snake[1].y+deltaY[direction], flags=flags[opposite[direction]], pellet=false}
			table.insert(snake, 1, nextSegment)
			if #snake > snakeLength then
				local endSegment = table.remove(snake)
				snake[#snake].flags = snake[#snake].flags - flags[opposite[endSegment.direction]]
			end
			if snake[1].x < 1 or snake[1].x>BOARD_COLUMNS or snake[1].y<1 or snake[1].y>BOARD_ROWS then
				inPlay = false
			elseif hasSnakeBody(snake[1].x,snake[1].y) then
				inPlay = false
			else
				if hasPellet(snake[1].x,snake[1].y) then
					removePellets(snake[1].x,snake[1].y)
					snake[1].pellet = true
					snakeLength=snakeLength + 2
					if #pellets==0 then
						addPellet()
					end
				end
			end
		end
	end
end

function updateStats(dt)
	if inPlay then
		
	end
end

function updateBoard()
	clearBoard()
	showSnake()
	showPellets()
	showStats()
end

function init(self)
	math.randomseed(os.time())
	msg.post(".","acquire_input_focus")
	clearBoard()
end

function update(self, dt)
	updateStats(dt)
	updateSnake(dt)
	updateBoard()
end

function on_input(self, action_id, action)
	if inPlay then
		if action_id == hash("up") and action.pressed then
			table.insert(commandQueue, DIRECTION_NORTH)
		elseif action_id == hash("down") and action.pressed  then
			table.insert(commandQueue, DIRECTION_SOUTH)
		elseif action_id == hash("left") and action.pressed then
			table.insert(commandQueue, DIRECTION_WEST)
		elseif action_id == hash("right") and action.pressed then
			table.insert(commandQueue, DIRECTION_EAST)
		end
	else
		if action_id == hash("green") then
			startGame()
		end
	end
end
